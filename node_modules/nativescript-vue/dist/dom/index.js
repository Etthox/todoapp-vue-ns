import { markRaw } from '@vue/runtime-core';
import { getViewClass, getViewMeta, normalizeElementName, } from '../registry';
import { ELEMENT_REF } from '../runtimeHelpers';
import setValue from 'set-value';
// import unset from 'unset-value'
const __TEST__ = false;
let nodeId = 0;
export class NSVNode {
    constructor(nodeType) {
        this.nodeType = nodeType;
        this.nodeId = nodeId++;
    }
    nodeId;
    nodeType;
    _text;
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        if (this.parentNode?.nodeType === "element" /* NSVNodeTypes.ELEMENT */) {
            this.parentNode.updateText();
        }
    }
    parentNode = null;
    childNodes = [];
    get nextSibling() {
        if (!this.parentNode) {
            return null;
        }
        const selfIndex = this.parentNode.childNodes.findIndex((n) => n.nodeId === this.nodeId);
        if (selfIndex > -1 && selfIndex < this.parentNode.childNodes.length - 1) {
            return this.parentNode.childNodes[selfIndex + 1];
        }
        return null;
    }
    get prevSibling() {
        if (!this.parentNode) {
            return null;
        }
        const selfIndex = this.parentNode.childNodes.findIndex((n) => n.nodeId === this.nodeId);
        if (selfIndex > 0) {
            return this.parentNode.childNodes[selfIndex - 1];
        }
        return null;
    }
    get firstChild() {
        return this.childNodes.length ? this.childNodes[0] : null;
    }
    get lastChild() {
        return this.childNodes.length
            ? this.childNodes[this.childNodes.length - 1]
            : null;
    }
}
export class NSVElement extends NSVNode {
    _tagName;
    _nativeView;
    _meta;
    _attributeOriginalValue = new Map();
    constructor(tagName) {
        super("element" /* NSVNodeTypes.ELEMENT */);
        this._tagName = normalizeElementName(tagName);
        const viewClass = getViewClass(tagName);
        this._nativeView = markRaw(new viewClass());
        this._nativeView[ELEMENT_REF] = this;
    }
    get tagName() {
        return this._tagName;
    }
    get nativeView() {
        return this._nativeView;
    }
    get style() {
        return this.nativeView.style;
    }
    set style(inlineStyle) {
        this.nativeView.style = inlineStyle;
    }
    get text() {
        return this.nativeView.text;
    }
    set text(t) {
        this.nativeView.text = t;
    }
    get meta() {
        if (this._meta) {
            return this._meta;
        }
        return (this._meta = getViewMeta(this.tagName));
    }
    addEventListener(event, handler, options = {}) {
        const { capture, once } = options;
        if (capture) {
            //   debug("Bubble propagation is not supported");
        }
        if (once) {
            const oldHandler = handler;
            const self = this;
            handler = (...args) => {
                oldHandler.call(null, ...args);
                self.removeEventListener(event, handler);
            };
        }
        this.nativeView.addEventListener(event, handler);
    }
    removeEventListener(event, handler) {
        this.nativeView.removeEventListener(event, handler);
    }
    dispatchEvent(event) {
        this.nativeView.notify({ eventName: event, object: this.nativeView });
    }
    getAttribute(name) {
        return this.nativeView[name];
    }
    setAttribute(name, value) {
        if (!this._attributeOriginalValue.has(name)) {
            this._attributeOriginalValue.set(name, this.nativeView[name]);
        }
        // this.nativeView[name] = value;
        setValue(this.nativeView, name, value);
    }
    removeAttribute(name) {
        // only remove attributes that we have set previously
        if (this._attributeOriginalValue.has(name)) {
            const originalValue = this._attributeOriginalValue.get(name);
            this._attributeOriginalValue.delete(name);
            // this.nativeView[name] = originalValue;
            setValue(this.nativeView, name, originalValue);
        }
        // potential issue: unsetValue is an empty object
        // not all properties/attributes may know/check for this
        // set(this.nativeView, name, unsetValue);
        // originally we deleted the property, but in case of built-in properties
        // this would break them. For example, deleting the padding property
        // will prevent us from changing the padding once we deleted it
        // that's not the expected behaviour.
        // unset(this.nativeView, name)
    }
    insertBefore(el, anchor) {
        if (!anchor) {
            return this.appendChild(el);
        }
        const refIndex = this.childNodes.findIndex((node) => node.nodeId === anchor.nodeId);
        if (refIndex === -1) {
            return this.appendChild(el);
        }
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
        this.childNodes.splice(refIndex, 0, el);
        el.parentNode = this;
        // find index to use for the native view, since non-visual nodes
        // (comment/text don't exist in the native view hierarchy)
        // todo: potentially refactor based on my benchmark:
        // https://www.measurethat.net/Benchmarks/Show/7450/0/filter-findindex
        const trueIndex = this.childNodes
            .filter((node) => node.nodeType === "element" /* NSVNodeTypes.ELEMENT */)
            .findIndex((node) => node.nodeId === el.nodeId);
        this.addChild(el, trueIndex);
    }
    appendChild(el) {
        this.childNodes.push(el);
        el.parentNode = this;
        this.addChild(el);
    }
    removeChild(el) {
        const index = this.childNodes.findIndex((node) => node.nodeId === el.nodeId);
        if (index > -1) {
            this.childNodes.splice(index, 1);
            el.parentNode = null;
            if (el.nodeType === "element" /* NSVNodeTypes.ELEMENT */) {
                removeChild(el, this);
            }
            else if (el.nodeType === "text" /* NSVNodeTypes.TEXT */) {
                this.updateText();
            }
        }
    }
    // abstracted from appendChild, and insertBefore to avoid code duplication
    addChild(el, atIndex) {
        if (el.nodeType === "element" /* NSVNodeTypes.ELEMENT */) {
            addChild(el, this, atIndex);
        }
        else if (el.nodeType === "text" /* NSVNodeTypes.TEXT */) {
            this.updateText();
        }
    }
    updateText() {
        this.setAttribute('text', this.childNodes.reduce((text, currentNode) => {
            if (currentNode.nodeType !== "text" /* NSVNodeTypes.TEXT */) {
                return text;
            }
            return text + currentNode.text;
        }, ''));
    }
}
export class NSVComment extends NSVNode {
    constructor(text) {
        super("comment" /* NSVNodeTypes.COMMENT */);
        this.text = text;
    }
}
export class NSVText extends NSVNode {
    constructor(text) {
        super("text" /* NSVNodeTypes.TEXT */);
        this.text = text;
    }
}
export class NSVRoot extends NSVNode {
    el;
    constructor() {
        super("root" /* NSVNodeTypes.ROOT */);
    }
    appendChild(el) {
        // console.log(`NSVRoot->appendChild(${el.nodeType})`)
        if (el instanceof NSVElement) {
            el.parentNode = this;
            this.el = el;
        }
        // no-op
    }
    removeChild(el) {
        // console.log('NSVRoot->removeCchild()');
        if (el === this.el) {
            this.el = null;
        }
    }
    insertBefore(el, anchor) {
        // console.error(
        //   "insertBefore called on NSVRoot - root element must contain a single child."
        // );
        return this.appendChild(el);
    }
}
function addChild(child, parent, atIndex) {
    if (__TEST__)
        return;
    // debug(
    //   `...addChild(  ${child.tagName}(${child.nodeId}), ${parent.tagName}(${
    //     parent.nodeId
    //   }), ${atIndex}  )`
    // )
    if (child.meta.viewFlags & 1 /* NSVViewFlags.SKIP_ADD_TO_DOM */) {
        // debug('SKIP_ADD_TO_DOM')
        return;
    }
    const parentView = parent.nativeView;
    const childView = child.nativeView;
    if (parent.meta.viewFlags & 8 /* NSVViewFlags.NO_CHILDREN */) {
        // debug('NO_CHILDREN')
        return;
    }
    if (parent.meta.nodeOps) {
        return parent.meta.nodeOps.insert(child, parent, atIndex);
    }
    if (parent.meta.viewFlags & 4 /* NSVViewFlags.LAYOUT_VIEW */) {
        if (typeof atIndex === 'number') {
            parentView.insertChild(childView, atIndex);
        }
        else {
            parentView.addChild(childView);
        }
    }
    else if (parent.meta.viewFlags & 2 /* NSVViewFlags.CONTENT_VIEW */) {
        parentView.content = childView;
    }
    else {
        parentView._addChildFromBuilder(childView.constructor.name, childView);
    }
}
function removeChild(child, parent) {
    if (__TEST__)
        return;
    // debug(
    //   `...removeChild(  ${child.tagName}(${child.nodeId}), ${parent.tagName}(${
    //     parent.nodeId
    //   })  )`
    // )
    if (child.meta.viewFlags & 1 /* NSVViewFlags.SKIP_ADD_TO_DOM */) {
        // debug('SKIP_ADD_TO_DOM')
        return;
    }
    if (parent.meta.viewFlags & 8 /* NSVViewFlags.NO_CHILDREN */) {
        // debug('NO_CHILDREN')
        return;
    }
    if (parent.meta.nodeOps) {
        return parent.meta.nodeOps.remove(child, parent);
    }
    const parentView = parent.nativeView;
    const childView = child.nativeView;
    if (parent.meta.viewFlags & 4 /* NSVViewFlags.LAYOUT_VIEW */) {
        parentView.removeChild(childView);
    }
    else if (parent.meta.viewFlags & 2 /* NSVViewFlags.CONTENT_VIEW */) {
        parentView.content = null;
    }
    else {
        parentView._removeView(childView);
    }
}
//# sourceMappingURL=index.js.map
import { invokeArrayFns, isArray } from "@vue/shared";
import { getViewMeta } from "../registry";
const getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"];
    return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function toNumber(val) {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
}
export const vModel = {
    beforeMount(el, { value, modifiers: { trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number;
        const { prop, event } = getViewMeta(el.tagName).model;
        el._assign(value);
        el.setAttribute(prop, value);
        el.addEventListener(event, () => {
            let propValue = el.getAttribute(prop);
            if (trim && typeof propValue === "string") {
                propValue = propValue.trim();
            }
            else if (castToNumber && typeof propValue === "string") {
                propValue = toNumber(propValue);
            }
            el._assign(propValue);
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        const { prop } = getViewMeta(el.tagName).model;
        el._assign = getModelAssigner(vnode);
        if (value === oldValue) {
            return;
        }
        el.setAttribute(prop, value);
    },
};
//# sourceMappingURL=vModel.js.map
export let defaultViewMeta = {
    viewFlags: 0, // NSVViewFlags.NONE - circular dependency, using constant value instead
};
let elementMap = {};
export function getViewMeta(elementName) {
    // console.log(`->getViewMeta(${elementName})`)
    const normalizedName = normalizeElementName(elementName);
    const entry = elementMap[normalizedName];
    if (!entry) {
        throw new Error(`No known component for element ${elementName}.`);
    }
    return entry.meta;
}
let unknownViewResolver;
export function registerUnknownViewResolver(resolver) {
    unknownViewResolver = resolver;
}
export function getViewClass(elementName) {
    // console.log(`->getViewClass(${elementName})`)
    const normalizedName = normalizeElementName(elementName);
    const entry = elementMap[normalizedName];
    if (!entry) {
        const resolved = unknownViewResolver?.(elementName);
        if (resolved) {
            return resolved;
        }
        throw new Error(`No known component for element ${elementName}.`);
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new Error(`Could not load view for: ${elementName}. ${e}`);
    }
}
export function normalizeElementName(elementName) {
    return elementName.replace(/-/g, '').toLowerCase();
}
export function registerElement(elementName, resolver, meta) {
    const normalizedName = normalizeElementName(elementName);
    const mergedMeta = Object.assign({}, defaultViewMeta, meta);
    if (elementMap[normalizedName] && !mergedMeta.overwriteExisting) {
        throw new Error(`Element for ${elementName} already registered.\n` +
            `If this is intentional set 'overwriteExisting: true' in 'meta'`);
    }
    elementMap[normalizedName] = {
        meta: mergedMeta,
        resolver,
    };
    // console.log(`->registerElement(${elementName})`)
}
export function isKnownView(elementName) {
    return elementMap.hasOwnProperty(normalizeElementName(elementName));
}
//# sourceMappingURL=index.js.map
import { defineComponent, getCurrentInstance, h, warn, watch, ref, Comment, } from '@vue/runtime-core';
import { ListView as NSCListView, ObservableArray, } from '@nativescript/core';
import { registerElement } from '../registry';
import { ELEMENT_REF } from '../runtimeHelpers';
registerElement('NSCListView', () => NSCListView, {
    viewFlags: 8 /* NSVViewFlags.NO_CHILDREN */,
});
function getListItem(item, index) {
    return {
        item,
        index,
        even: index % 2 === 0,
        odd: index % 2 !== 0,
    };
}
const LIST_CELL_ID = Symbol('list_cell_id');
export const ListView = /*#__PURE__*/ defineComponent({
    name: 'ListView',
    props: {
        items: {
            validator(value) {
                return Array.isArray(value) || value instanceof ObservableArray;
            },
        },
        itemTemplateSelector: Function,
    },
    setup(props, ctx) {
        const itemTemplates = Object.keys(ctx.slots).map((slotName) => {
            return {
                key: slotName,
                createView() {
                    // no need to return anything here
                },
            };
        });
        const getSlotName = (itemCtx) => props.itemTemplateSelector?.(itemCtx) ?? 'default';
        const listView = ref(null);
        const vm = getCurrentInstance();
        watch(props, () => {
            try {
                if (props.items instanceof ObservableArray) {
                    return;
                }
                const lv = listView.value?.nativeView;
                lv?.refresh();
            }
            catch (err) {
                console.error('Error while refreshing ListView', err);
            }
        });
        let cellId = 0;
        const cells = ref({});
        function onitemLoading(event) {
            const el = event.view?.[ELEMENT_REF];
            const id = el?.nativeView[LIST_CELL_ID] ?? `LIST_CELL_${cellId++}`;
            const itemCtx = getListItem(props.items instanceof ObservableArray
                ? props.items.getItem(event.index)
                : props.items[event.index], event.index);
            // update the cell data with the current row
            cells.value[id] = {
                itemCtx,
                slotName: getSlotName(itemCtx),
            };
            // trigger an update!
            vm.update();
            // find the vnode rendering this cell
            const vnode = vm.subTree.children.find((vnode) => {
                return vnode.key === id;
            });
            // store the cell id on the Element itself so we can retrieve it when recycling kicks in
            const cellEl = vnode.el.nativeView;
            cellEl[LIST_CELL_ID] = id;
            // finally, set the event.view to the rendered cellEl
            event.view = cellEl;
        }
        function itemTemplateSelector(item, index) {
            // pass on the template selector call with the ListItem context
            return getSlotName(getListItem(item, index));
        }
        // render all realized templates as children
        const cellVNODES = () => Object.entries(cells.value).map(([id, entry]) => {
            const vnodes = ctx.slots[entry.slotName]?.(entry.itemCtx) ?? [];
            const nonCommentVnodes = vnodes.filter((vnode) => vnode.type !== Comment);
            if (nonCommentVnodes.length === 0) {
                warn(`ListView template must contain at least one element.`);
            }
            else if (nonCommentVnodes.length > 1) {
                warn(`ListView template must contain a single root element. Found: ${vnodes.length}. Only the first one will be used.`);
            }
            const vnode = nonCommentVnodes.at(0) ??
                // default template is just a label
                h('Label', {
                    text: entry.itemCtx.item,
                });
            // set the key to the list cell id, so we can find this cell later...
            vnode.key = id;
            return vnode;
        });
        return () => {
            return h('NSCListView', {
                ref: listView,
                items: props.items,
                itemTemplates,
                itemTemplateSelector,
                onitemLoading,
            }, cellVNODES());
        };
    },
});
//# sourceMappingURL=ListView.js.map